import nodemailer from "nodemailer";
import dotenv from "dotenv";

dotenv.config();


import Imap from "imap-simple";
import { simpleParser } from "mailparser";
import Ticket from "../models/ticket.model";
import { TicketStatus } from "../dtos/ticket.dto";
/**
 * Sends an email using Nodemailer
 * @param to Recipient email address
 * @param subject Subject of the email
 * @param text Plain text body of the email
 * @param html HTML body of the email
 * @returns Email sending status or error
 */
const sendEmail = async (
  to: string,
  subject: string,
  text: string,
  html: string
): Promise<string> => {
  const smtpHost = process.env.SMTP_HOST;
  const smtpPort = process.env.SMTP_PORT;
  const emailUser = process.env.EMAIL_USERNAME;
  const emailPass = process.env.EMAIL_PASSWORD;




  if (!smtpHost || !smtpPort || !emailUser || !emailPass) {
    throw new Error(
      "SMTP configuration is missing. Please check your environment variables."
    );
  }

  const transporter = nodemailer.createTransport({
    host: smtpHost,
    secure: true,
    port: parseInt(smtpPort, 10),
    auth: {
      user: emailUser,
      pass: emailPass,
    },
    tls: { rejectUnauthorized: false }
  });

  const mailOptions = {
    from: emailUser, // sender address
    to,
    subject,
    text,
    html,
  };

  try {
    const info = await transporter.sendMail(mailOptions);
    console.log("Email sent: " + info.response);
    return `Email sent successfully to ${to}`;
  } catch (error) {
    console.error("Error sending email:", error);
    throw new Error("Failed to send email.");
  }
};

const sendEmailWithCC = async (
  to: string,
  cc: string[],
  subject: string,
  text: string,
  html: string
) => {
  const smtpHost = process.env.SMTP_HOST;
  const smtpPort = process.env.SMTP_PORT;
  const emailUser = process.env.EMAIL_USERNAME;
  const emailPass = process.env.EMAIL_PASSWORD;

  if (!smtpHost || !smtpPort || !emailUser || !emailPass) {
    throw new Error("SMTP config missing.");
  }

  const transporter = nodemailer.createTransport({
    host: smtpHost,
    secure: false,
    port: parseInt(smtpPort, 10),
    auth: {
      user: emailUser,
      pass: emailPass,
    },
    tls: { rejectUnauthorized: false }
  });

  const mailOptions = {
    from: emailUser,
    to,
    cc, // ðŸŸ¢ CC added here
    subject,
    text,
    html,
  };

  try {
    const info = await transporter.sendMail(mailOptions);
    console.log("Email sent:", info.response);
    return info;
  } catch (error) {
    console.log("Error sending CC email:", error);
    throw error;
  }
};


interface TicketEmailPayload {
  to: string;
  subject: string;
  studentName?: string;
  title: string;
  description: string;
  remarks?: string;
}



const sendTicketCreationEmail = async (data: TicketEmailPayload) => {
  try {
    const ccEnv = process.env.TICKET_CC_EMAILS || "";
    const ccList = ccEnv
      .split(",")
      .map((e) => e.trim())
      .filter((e) => e.length > 0);

    const fromName = process.env.TICKET_NAME || "Support Desk";

    const emailSubject = `[MR-TICKET:${data.subject}] ${data.title}`;

    // HTML VERSION
    const html = `
      <div style="font-family: Arial, sans-serif; color: #333;">
        <h2>${fromName}</h2>
        <p><strong>Ticket ID:</strong> ${data.subject}</p>
        <p><strong>Title:</strong> ${data.title}</p>
        <p><strong>Description:</strong></p>
        <p>${data.description}</p>

        ${data.remarks
        ? `<p><strong>Remarks:</strong> ${data.remarks}</p>`
        : ""
      }

        ${data.studentName
        ? `<p><strong>Student:</strong> ${data.studentName}</p>`
        : ""
      }

        <hr style="border:0;border-top:1px solid #ccc;margin:20px 0;">
        <p>This email was auto-generated by the Student Support System.</p>
      </div>
    `;

    // TEXT VERSION
    const text = `
Ticket ID: ${data.subject}
Title: ${data.title}
Description: ${data.description}
${data.remarks ? `Remarks: ${data.remarks}` : ""}
${data.studentName ? `Student: ${data.studentName}` : ""}
    `;

    // ðŸ”¥ FIRE EMAIL â€” using your existing sendEmail() but with CC added
    await sendEmailWithCC(data.to, ccList, emailSubject, text, html);

    return true;
  } catch (err) {
    console.error("Error sending ticket creation email:", err);
    throw err;
  }
};




const config = {
  imap: {
    user: process.env.EMAIL_USERNAME,
    password: process.env.EMAIL_PASSWORD,
    host: "imap.gmail.com",
    port: 993,
    tls: true,
    tlsOptions: { rejectUnauthorized: false },
    authTimeout: 5000,
    connTimeout: 10000,
    keepalive: false,
  },
};


const toImapDate = (date: Date) => {
  const day = date.getDate();
  const month = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
  ][date.getMonth()];
  const year = date.getFullYear();
  return `${day}-${month}-${year}`;
};


const runEmailCheck = async () => {
  let connection;

  try {
    // Create fresh connection every cycle
    connection = await Imap.connect(config);
    await connection.openBox("[Gmail]/All Mail");

    const sinceTime = new Date(Date.now() - 5 * 60 * 1000);
    const imapSince = toImapDate(sinceTime);

    const messages = await connection.search(
      [
        ["SINCE", imapSince],
        ["SUBJECT", "MR-TICKET:"],
      ],
      {
        bodies: [""],
        markSeen: true,
      }
    );

    for (const message of messages) {
      const all = message.parts.find((p) => p.which === "");
      if (!all) continue;

      const parsed = await simpleParser(all.body);

      const subject = parsed.subject || "";
      const from = parsed.from?.text || "";
      const html = parsed.html || "";
      const text = parsed.text || "";
      const messageId = parsed.messageId || "";

      console.log("ðŸ“¬ RAW SUBJECT:", subject);
      console.log("ðŸ†” Message-ID:", messageId);

      if (!messageId) continue;

      // Ignore system outgoing emails
      if (from.includes(process.env.EMAIL_USERNAME)) {
        console.log("â›” Ignored outbound system email");
        continue;
      }

      const match = subject.match(/\[MR-TICKET:([^\]]+)\]/);
      if (!match) {
        console.log("âŒ No ticket ID found");
        continue;
      }

      const ticketId = match[1].trim();

      // Skip already processed emails
      const already = await Ticket.findOne({
        subject: ticketId,
        "remarks.messageId": messageId,
      });

      if (already) {
        console.log("â›” Duplicate reply skipped:", messageId);
        continue;
      }

      // Find ticket
      const ticket = await Ticket.findOne({ subject: ticketId });
      console.log("ðŸ” DB Ticket Found:", ticket ? ticket._id : "NO");

      if (!ticket) continue;

      // Save new remark
      await Ticket.findOneAndUpdate(
        { subject: ticketId },
        {
          $push: {
            remarks: {
              messageId,
              title: `Reply from ${from}`,
              subject,
              description: html || text,
              createdAt: new Date(),
            },
          },
          status: TicketStatus.REPLY_GIVEN,
        }
      );

      console.log(`âœ… Ticket ${ticketId} updated`);
    }

  } catch (err: any) {
    console.error("âŒ IMAP Polling Error:", err.message);

  } finally {
    // Close connection cleanly
    if (connection) {
      try {
        await connection.end();
      } catch (_) { }
    }
  }
};


const startEmailReplyListener = () => {
  console.log("ðŸ“¥ Email Reply Listener Running...");
  setInterval(runEmailCheck, 8000);
};



export { sendEmail, sendTicketCreationEmail, startEmailReplyListener };
