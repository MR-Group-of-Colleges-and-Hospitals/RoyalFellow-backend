import nodemailer from "nodemailer";
import dotenv from "dotenv";

dotenv.config();


import Imap from "imap-simple";
import { simpleParser } from "mailparser";
import Ticket from "../models/ticket.model";
import { TicketStatus } from "../dtos/ticket.dto";
/**
 * Sends an email using Nodemailer
 * @param to Recipient email address
 * @param subject Subject of the email
 * @param text Plain text body of the email
 * @param html HTML body of the email
 * @returns Email sending status or error
 */
const sendEmail = async (
  to: string,
  subject: string,
  text: string,
  html: string
): Promise<string> => {
  const smtpHost = process.env.SMTP_HOST;
  const smtpPort = process.env.SMTP_PORT;
  const emailUser = process.env.EMAIL_USERNAME;
  const emailPass = process.env.EMAIL_PASSWORD;




  if (!smtpHost || !smtpPort || !emailUser || !emailPass) {
    throw new Error(
      "SMTP configuration is missing. Please check your environment variables."
    );
  }

  const transporter = nodemailer.createTransport({
    host: smtpHost,
    secure: true,
    port: parseInt(smtpPort, 10),
    auth: {
      user: emailUser,
      pass: emailPass,
    },
    tls: { rejectUnauthorized: false }
  });

  const mailOptions = {
    from: emailUser, // sender address
    to,
    subject,
    text,
    html,
  };

  try {
    const info = await transporter.sendMail(mailOptions);
    console.log("Email sent: " + info.response);
    return `Email sent successfully to ${to}`;
  } catch (error) {
    console.error("Error sending email:", error);
    throw new Error("Failed to send email.");
  }
};

const sendEmailWithCC = async (
  to: string,
  cc: string[],
  subject: string,
  text: string,
  html: string
) => {
  const smtpHost = process.env.SMTP_HOST;
  const smtpPort = process.env.SMTP_PORT;
  const emailUser = process.env.EMAIL_USERNAME;
  const emailPass = process.env.EMAIL_PASSWORD;

  if (!smtpHost || !smtpPort || !emailUser || !emailPass) {
    throw new Error("SMTP config missing.");
  }

  const transporter = nodemailer.createTransport({
    host: smtpHost,
    secure: false,
    port: parseInt(smtpPort, 10),
    auth: {
      user: emailUser,
      pass: emailPass,
    },
    tls: { rejectUnauthorized: false }
  });

  const mailOptions = {
    from: emailUser,
    to,
    cc, // üü¢ CC added here
    subject,
    text,
    html,
  };

  try {
    const info = await transporter.sendMail(mailOptions);
    console.log("Email sent:", info.response);
    return info;
  } catch (error) {
    console.log("Error sending CC email:", error);
    throw error;
  }
};


interface TicketEmailPayload {
  to: string;
  subject: string;
  studentName?: string;
  title: string;
  description: string;
  remarks?: string;
}



const sendTicketCreationEmail = async (data: TicketEmailPayload) => {
  try {
    const ccEnv = process.env.TICKET_CC_EMAILS || "";
    const ccList = ccEnv
      .split(",")
      .map((e) => e.trim())
      .filter((e) => e.length > 0);

    const fromName = process.env.TICKET_NAME || "Support Desk";

    const emailSubject = `[MR-TICKET:${data.subject}] ${data.title}`;

    // HTML VERSION
    const html = `
      <div style="font-family: Arial, sans-serif; color: #333;">
        <h2>${fromName}</h2>
        <p><strong>Ticket ID:</strong> ${data.subject}</p>
        <p><strong>Title:</strong> ${data.title}</p>
        <p><strong>Description:</strong></p>
        <p>${data.description}</p>

        ${data.remarks
        ? `<p><strong>Remarks:</strong> ${data.remarks}</p>`
        : ""
      }

        ${data.studentName
        ? `<p><strong>Student:</strong> ${data.studentName}</p>`
        : ""
      }

        <hr style="border:0;border-top:1px solid #ccc;margin:20px 0;">
        <p>This email was auto-generated by the Student Support System.</p>
      </div>
    `;

    // TEXT VERSION
    const text = `
Ticket ID: ${data.subject}
Title: ${data.title}
Description: ${data.description}
${data.remarks ? `Remarks: ${data.remarks}` : ""}
${data.studentName ? `Student: ${data.studentName}` : ""}
    `;

    // üî• FIRE EMAIL ‚Äî using your existing sendEmail() but with CC added
    await sendEmailWithCC(data.to, ccList, emailSubject, text, html);

    return true;
  } catch (err) {
    console.error("Error sending ticket creation email:", err);
    throw err;
  }
};




const config = {
  imap: {
    user: process.env.EMAIL_USERNAME,       // Gmail / Zoho mailbox
    password: process.env.EMAIL_PASSWORD,
    host: "imap.gmail.com",                 // For Zoho: imap.zoho.com
    port: 993,
    tls: true,
    tlsOptions: { rejectUnauthorized: false }
  }
};


const toImapDate = (date: Date) => {
  const day = date.getDate();
  const month = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][date.getMonth()];
  const year = date.getFullYear();
  return `${day}-${month}-${year}`;
};

const startEmailReplyListener = async () => {
  try {
    const connection = await Imap.connect(config);

    await connection.openBox("[Gmail]/All Mail");

    console.log("üì• Email Reply Listener Running...");

    setInterval(async () => {
      const sinceTime = new Date(Date.now() - 5 * 60 * 1000);
      const imapSince = toImapDate(sinceTime);

      // Only MR-TICKET mails since today (day precision), any flags (seen/unseen)
      const messages = await connection.search(
        [
          ["SINCE", imapSince],
          ["SUBJECT", "MR-TICKET:"],
        ],
        {
          bodies: [""],
          markSeen: true,
        }
      );

      for (const message of messages) {
        const all = message.parts.find((p) => p.which === "");
        if (!all) continue;

        const parsed = await simpleParser(all.body);

        const subject = parsed.subject || "";
        const from = parsed.from?.text || "";
        const html = parsed.html || "";
        const text = parsed.text || "";
        const messageId = parsed.messageId || "";

        console.log("üì¨ RAW SUBJECT:", subject);
        console.log("üÜî Message-ID:", messageId);

        // 1. Must have a messageId to dedupe
        if (!messageId) {
          console.log("‚ö†Ô∏è No Message-ID, skipping");
          continue;
        }
        if (from.includes(process.env.EMAIL_USERNAME)) {
          console.log("‚õî Ignored outbound system email");
          continue;
        }

        // 2. Extract ticketId from subject
        const match = subject.match(/\[MR-TICKET:([^\]]+)\]/);
        if (!match) {
          console.log("‚ùå No ticket ID found");
          continue;
        }

        const ticketId = match[1].trim();
        console.log("üéØ Extracted TicketId:", ticketId);

        // 3. Check if this email was already processed
        const already = await Ticket.findOne({
          subject: ticketId,
          "remarks.messageId": messageId,
        });

        if (already) {
          console.log("‚õî Duplicate reply skipped:", messageId);
          continue;
        }

        // 4. Find ticket
        const ticket = await Ticket.findOne({ subject: ticketId });
        console.log("üîç DB Ticket Found:", ticket ? ticket._id : "NO");

        if (!ticket) continue;

        // 5. Add remark only once
        await Ticket.findOneAndUpdate(
          { subject: ticketId },
          {
            $push: {
              remarks: {
                messageId,                          // üÜï so we can skip next time
                title: `Reply from ${from}`,
                subject,
                description: html || text,
                createdAt: new Date(),
              },
            },
            status: TicketStatus.REPLY_GIVEN,
          }
        );

        console.log(`‚úÖ Ticket ${ticketId} updated`);
      }
    }, 8000);
  } catch (err) {
    console.error("‚ùå Email Reply Listener Error:", err);
  }
};




export { sendEmail, sendTicketCreationEmail, startEmailReplyListener };
